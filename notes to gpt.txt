I'm making a taikyoku shogi engine in C++. taikyoku shogi is a 2-player large-board variant of shogi with exactly 301 unique pieces. It is played on a 36x36 board. Pieces can be owned by either player (0 for first player, 1 for second player). When pieces reach the 11 ranks on the opponent's side of the board, they promote to a different piece. Pieces can promote only once, and some pieces can't promote at all. Most pieces have simple movements: they start at one position, and end at another position. However, there are some other pieces which move specially.
One such piece is the capricorn (C). It moves like a bishop twice, meaning that it may cross over into the promotion zone then go out again. For capricorn moves, an additional bit is set indicating it should promote.
Another class of special pieces is the 6 range capturing pieces. These can move as a rook, bishop or queen (depending on the piece) but jump over everything in their way, capture ALL pieces in the way. This means they can capture entire rows of the board at once. However, some range capturing pieces can perform regular jump moves, meaning that an additional bit flag is set indicating if it should capture everything in the way or not.
Another class of pieces with special movements is the lion-like pieces. These pieces may move normally, but they also may make two king steps in one move, meaning they can possible capture two pieces in one move (lion power). If the middle step is over the promotion zone, the pieces will promote at the end of its turn. Moves for lion-like pieces have an extra 5 bits, indicating if it does a middle step with the lion power, and if so, the relative position of the middle step (2 bits: x, 2 bits: y).
The last special piece is the free eagle (FE), which can either move normally, or may capture some pieces in front of it then continue sliding in that direction like a queen. Depending on the direction, it may capture either 3 or 4 pieces in front of it in one direction, then continue sliding like a queen in that direction. This still means it can capture a piece at the end of the slide. Moves with the free eagle have 2 extra bits: 1 controlling if it captures all in a row, and 1 controlling if it captures 3 or 4.
All extra bits in the move will be set to 0 if they are not used. Moves are guaranteed to be valid (i.e. not referring to locations outside the board)

The code first loads pieces from a CSV with exactly 302 rows (first one is the header), which has columns for the species name as a string, the movement Betza notation, and the string name of which piece it promotes to. Strings for species names are then converted to numerical IDs, from 1 - 301. 0 represents no piece.

Look at the code below and vigorously proof-read and check it for logic errors. Make sure it will deal with all the special pieces correctly.

```template <typename T>
T sign(T x) {
	return (x > 0) - (x < 0);
}

#define NUM_UNIQUE_PIECES 301

std::unordered_map<std::string, uint16_t> pieceIds;
std::array<std::string, NUM_UNIQUE_PIECES + 1> pieceBetzas;
std::array<uint16_t, NUM_UNIQUE_PIECES + 1> piecePromotions;

void initialisePieces() {
	CSVReader reader("pieces.csv");
	std::array<std::string, NUM_UNIQUE_PIECES + 1> piecePromotionSpecies;
	uint16_t i = 0;
	for(auto &row : reader) {
		if(i == 0) {
			i++;
			continue;
		}
		auto species = row["code"].get<>();
		auto movement = row["movement"].get<>();
		auto promotion = row["promotion"].get<>();
		pieceIds[species] = i;
		pieceBetzas[i] = movement;
		piecePromotionSpecies[i] = promotion;
		i++;
	}
	piecePromotions[0] = 0; // maybe not needed but can't hurt
	for(int i = 1; i < NUM_UNIQUE_PIECES + 1; i++) {
		std::string promotion = piecePromotionSpecies[i];
		piecePromotions[i] = promotion == "-"? 0 : pieceIds[promotion];
	}
}
uint16_t createPiece(std::string species, bool canPromote, uint8_t owner) {
	uint16_t id = pieceIds[species];
	return createPiece(id, canPromote, owner);
}
uint16_t createPiece(uint16_t id, bool canPromote, uint8_t owner) {
	// std::cout << "creating piece " << species << " = " << id << std::endl;
	return (owner << 10) | (canPromote << 9) | id;
}
uint8_t getPieceOwner(uint16_t piece) {
	return piece >> 10;
}
uint16_t canPiecePromote(uint16_t piece) {
	return ((piece >> 9) & 1) && piecePromotions[getPieceSpecies(piece)] != 0;
}
uint16_t getPieceSpecies(uint16_t piece) {
	return piece & 0b111111111;
}


struct GameState {
	std::array<uint16_t, 1296> board;
	uint8_t currentPlayer;
	int32_t absEvaluation;
};

uint16_t getSquare(GameState &gameState, uint8_t x, uint8_t y) {
	return gameState.board[x + 36 * y];
}
void setSquare(GameState &gameState, uint8_t x, uint8_t y, uint16_t piece) {
	gameState.board[x + 36 * y] = piece;
}
void clearSquare(GameState &gameState, uint8_t x, uint8_t y) {
	gameState.board[x + 36 * y] = 0;
}
std::string gameStateToString(const GameState &state) {
	std::ostringstream oss;
	oss << "Player: " << static_cast<int>(state.currentPlayer) << "\nBoard: [";
	for(size_t i = 0; i < state.board.size(); i++) {
		oss << state.board[i];
		if(i != state.board.size() - 1) oss << ", ";
	}
	oss << "]";
	return oss.str();
}
int evaluateGameState(GameState &gameState) {
	if(gameState.currentPlayer) {
		return gameState.absEvaluation * -1;
	}
	return gameState.absEvaluation;
}
void makeMove(GameState &gameState, uint32_t move) {
	// move layout:
	// 6 bits: src x, 6 bits: src y
	// 6 bits: dst x, 6 bits: dst y
	// for capricorn, 1 bit extra: promotion
	// for range capturing pieces, 1 bit extra: capture all
	// for lion-like pieces, extra 1 bit: does middle step, extra 2 bits: middle step x offset, extra 2 bits: middle step y offset
	// for free eagle, 1 bit extra: captured all in the way, 1 bit more extra: capturing 3 or 4
	
	uint8_t srcX = (move >> 18) & 0b111111;
	uint8_t srcY = (move >> 12) & 0b111111;
	uint16_t piece = getSquare(gameState, srcX, srcY);
	uint8_t destX = (move >> 6) & 0b111111;
	uint8_t destY = move & 0b111111;
	uint16_t pieceSpecies = getPieceSpecies(piece);
	uint8_t pieceOwner = getPieceOwner(piece);
	bool middleStepShouldPromote = false;
	if(pieceSpecies == pieceIds["C"]) {
		middleStepShouldPromote = move >> 24;
	} else if(pieceSpecies == pieceIds["L"] || pieceSpecies == pieceIds["FFI"] || pieceSpecies == pieceIds["BS"] || pieceSpecies == pieceIds["H"]) {
		// lion-like pieces
		int8_t doesMiddleStep = move >> 28;
		if(doesMiddleStep) {
			int8_t middleStepX = ((move >> 26) & 0b11) - 1;
			int8_t middleStepY = ((move >> 24) & 0b11) - 1;
			uint8_t middleY = srcY + middleStepY;
			setSquare(gameState, srcX + middleStepX, middleY, 0);
			middleStepShouldPromote = inPromotionZone(pieceOwner, middleY);
		}
	} else if(pieceSpecies == pieceIds["FE"]) {
		// free eagle
		bool captureAllFlag = move >> 24;
		if(captureAllFlag) {
			int8_t dirX = sign(destX - srcX);
			int8_t dirY = sign(destY - srcY);
			bool shouldMove4 = move >> 25;
			uint8_t steps = 3 + shouldMove4;
			uint8_t x = srcX + dirX;
			uint8_t y = srcY + dirY;
			for(uint8_t i = 0; i < steps; i++) {
				setSquare(gameState, x, y, 0);
				x += dirX;
				y += dirY;
			}
		}
	} else if(pieceSpecies == pieceIds["GG"] || pieceSpecies == pieceIds["VG"] || pieceSpecies == pieceIds["FLG"] || pieceSpecies == pieceIds["AG"] || pieceSpecies == pieceIds["FID"] || pieceSpecies == pieceIds["FCR"]) {
		// range capturing pieces
		bool captureAllFlag = move >> 24;
		if(captureAllFlag) {
			int8_t dirX = sign(destX - srcX);
			int8_t dirY = sign(destY - srcY);
			uint8_t x = srcX + dirX;
			uint8_t y = srcY + dirY;
			int i = 0;
			while(x != destX || y != destY) {
				setSquare(gameState, x, y, 0);
				x += dirX;
				y += dirY;
				if(i++ > 100) {
					std::cout << "log Error: Range capturing has failed! src: " << srcX << "," << srcY << "   dest: " << destX << "," << destY << "   dir: " << dirX << "," << dirY << std::endl; 
					throw std::runtime_error("Range capturing fail");
				}
			}
		}
	}
	
	bool shouldPromote = middleStepShouldPromote || inPromotionZone(pieceOwner, destY);
	if(shouldPromote && canPiecePromote(piece)) {
		piece = createPiece(piecePromotions[getPieceSpecies(piece)], 0, pieceOwner);
	}
	
	setSquare(gameState, srcX, srcY, 0);
	setSquare(gameState, destX, destY, piece);
}
inline bool inPromotionZone(uint8_t owner, uint8_t y) {
	return owner? y > 24 : y < 11;
}
```